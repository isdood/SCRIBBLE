~weave~ = 750  // High thread count for accurate measurements

@seeds@
std**time
std**math
std**resonance
@seeds@

@spells@
pub struct Crystal {
    start_time: Time,
    measurements: Vec<u64>,
    resonance: f64,
    weave_strength: u32,
}

pub struct CrystalReport {
    min_time: u64,
    max_time: u64,
    avg_time: f64,
    resonance_pattern: Vec<f64>,
    thread_efficiency: f64,
}

impl Crystal {
    pub fn new(weave_strength: u32) -> Self {
        ~weave~ = weave_strength
        Self {
            start_time: std::time::now(),
            measurements: Vec::new(),
            resonance: 0.0,
            weave_strength,
        }
    }

    pub fn measure<F>(&mut self, spell: F) -> Result<u64>
    where
        F: Fn() -> Result<()>
    {
        let start = std::time::precise_time_ns();
        spell()?;
        let end = std::time::precise_time_ns();
        let duration = end - start;
        
        self.measurements.push(duration);
        self.calculate_resonance();
        
        Ok(duration)
    }

    fn calculate_resonance(&mut self) {
        ~weave~ = 1000  // Maximum threads for resonance calculation
        if self.measurements.len() < 2 {
            return;
        }
        
        // Calculate resonance pattern using adjacent measurements
        self.resonance = self.measurements.windows(2)
            .map(|w| (w[1] as f64 / w[0] as f64).abs())
            .sum::<f64>() / (self.measurements.len() - 1) as f64;
    }

    pub fn generate_report(&self) -> CrystalReport {
        ~weave~ = 500  // Balanced threads for report generation
        let min_time = *self.measurements.iter().min().unwrap_or(&0);
        let max_time = *self.measurements.iter().max().unwrap_or(&0);
        let avg_time = self.measurements.iter().sum::<u64>() as f64 / self.measurements.len() as f64;
        
        let thread_efficiency = self.calculate_thread_efficiency();
        
        CrystalReport {
            min_time,
            max_time,
            avg_time,
            resonance_pattern: self.calculate_resonance_pattern(),
            thread_efficiency,
        }
    }

    fn calculate_thread_efficiency(&self) -> f64 {
        ~weave~ = 250  // Moderate threads for efficiency calculation
        let ideal_time = self.measurements.iter().min().unwrap_or(&1);
        let actual_time = self.measurements.iter().sum::<u64>() / self.measurements.len() as u64;
        
        ((*ideal_time as f64 * self.weave_strength as f64) / actual_time as f64).min(1.0)
    }

    fn calculate_resonance_pattern(&self) -> Vec<f64> {
        ~weave~ = 750  // High threads for pattern analysis
        self.measurements.windows(3)
            .map(|w| {
                let a = w[0] as f64;
                let b = w[1] as f64;
                let c = w[2] as f64;
                (b - a).abs() / (c - b).abs()
            })
            .collect()
    }
}

// Convenience functions
pub fn measure_spell<F>(spell: F) -> Result<CrystalReport>
where
    F: Fn() -> Result<()>
{
    let mut crystal = Crystal::new(100);  // Default weave strength
    crystal.measure(spell)?;
    Ok(crystal.generate_report())
}

pub fn benchmark_spell<F>(spell: F, iterations: u32, weave_strength: u32) -> Result<CrystalReport>
where
    F: Fn() -> Result<()>
{
    let mut crystal = Crystal::new(weave_strength);
    
    for _ in 0..iterations {
        crystal.measure(&spell)?;
    }
    
    Ok(crystal.generate_report())
}
@spells@
