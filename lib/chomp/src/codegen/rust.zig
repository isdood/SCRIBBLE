///! Rust Code Generator
///! ================
///! Author: Caleb J.D. Terkovics <isdood>
///! Created: 2025-01-21 02:49:34 UTC
///! License: MIT

const std = @import("std");
const ir = @import("../ir/mod.zig");
const safety = @import("../safety/mod.zig");

pub const RustGenerator = struct {
    codegen: *CodeGen,
    buffer: std.ArrayList(u8),
    indent_level: usize,

    const Self = @This();

    pub fn init(codegen: *CodeGen) !*Self {
        return Self{
            .codegen = codegen,
            .buffer = std.ArrayList(u8).init(codegen.allocator),
            .indent_level = 0,
        };
    }

    pub fn generate(self: *Self) !void {
        try self.generateHeader();
        try self.generateImports();
        try self.generateTypes();
        try self.generateFunctions();
        try self.generateFFIExports();
    }

    fn generateHeader(self: *Self) !void {
        try self.writeLine("// Generated by Chomp");
        try self.writeLine("// Created: 2025-01-21 02:49:34 UTC");
        try self.writeLine("");
    }

    fn generateImports(self: *Self) !void {
        try self.writeLine("#![allow(non_snake_case)]");
        try self.writeLine("#![allow(dead_code)]");
        try self.writeLine("");
        try self.writeLine("use std::ffi::c_void;");
        try self.writeLine("use chomp_runtime::safety;");
        try self.writeLine("");
    }

    fn generateTypes(self: *Self) !void {
        for (self.codegen.ir_module.types) |type_def| {
            try self.generateType(type_def);
        }
    }

    fn generateType(self: *Self, type_def: *ir.TypeDef) !void {
        switch (type_def.kind) {
            .struct_ => try self.generateStruct(type_def),
            .enum_ => try self.generateEnum(type_def),
            .union_ => try self.generateUnion(type_def),
        }
    }

    fn generateStruct(self: *Self, struct_def: *ir.TypeDef) !void {
        // Add safety attributes
        try self.writeLine("#[repr(C)]");
        if (self.codegen.safety_level == .strict) {
            try self.writeLine("#[derive(Debug, SafetyVerified)]");
        }

        try self.writeLine("pub struct {} {{", .{struct_def.name});
        self.indent();

        // Generate fields with safety annotations
        for (struct_def.fields) |field| {
            try self.writeLine("pub {}: {},", .{
                field.name,
                self.typeToRust(field.type)
            });
        }

        self.dedent();
        try self.writeLine("}}\n");

        // Generate implementation with safety checks
        if (self.codegen.safety_level == .strict) {
            try self.generateSafetyImpl(struct_def);
        }
    }

    fn generateSafetyImpl(self: *Self, type_def: *ir.TypeDef) !void {
        try self.writeLine("impl {} {{", .{type_def.name});
        self.indent();

        // Add safety verification
        try self.writeLine("pub fn verify(&self) -> Result<(), SafetyError> {");
        self.indent();
        try self.writeLine("safety::verify_ownership(self)?;");
        try self.writeLine("safety::verify_memory_safety(self)?;");
        try self.writeLine("Ok(())");
        self.dedent();
        try self.writeLine("}");

        self.dedent();
        try self.writeLine("}}\n");
    }

    fn typeToRust(self: Self, ir_type: *ir.Type) []const u8 {
        return switch (ir_type.kind) {
            .i32 => "i32",
            .u32 => "u32",
            .f32 => "f32",
            .bool => "bool",
            .string => "&str",
            .custom => ir_type.name,
        };
    }
};
