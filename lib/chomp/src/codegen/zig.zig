///! Zig Code Generator
///! ================
///! Author: Caleb J.D. Terkovics <isdood>
///! Created: 2025-01-21 02:49:34 UTC
///! License: MIT

const std = @import("std");
const ir = @import("../ir/mod.zig");
const safety = @import("../safety/mod.zig");

pub const ZigGenerator = struct {
    codegen: *CodeGen,
    buffer: std.ArrayList(u8),
    indent_level: usize,

    const Self = @This();

    pub fn init(codegen: *CodeGen) !*Self {
        return Self{
            .codegen = codegen,
            .buffer = std.ArrayList(u8).init(codegen.allocator),
            .indent_level = 0,
        };
    }

    pub fn generate(self: *Self) !void {
        try self.generateHeader();
        try self.generateImports();
        try self.generateTypes();
        try self.generateFunctions();
        try self.generateExports();
    }

    fn generateHeader(self: *Self) !void {
        try self.writeLine("// Generated by Chomp");
        try self.writeLine("// Created: 2025-01-21 02:49:34 UTC");
        try self.writeLine("");
    }

    fn generateImports(self: *Self) !void {
        try self.writeLine("const std = @import(\"std\");");
        try self.writeLine("const safety = @import(\"safety\");");

        // Add Rust FFI imports if needed
        if (self.hasRustDependencies()) {
            try self.writeLine("const rust = @import(\"rust\");");
        }
        try self.writeLine("");
    }

    fn generateTypes(self: *Self) !void {
        for (self.codegen.ir_module.types) |type_def| {
            try self.generateType(type_def);
        }
    }

    fn generateType(self: *Self, type_def: *ir.TypeDef) !void {
        switch (type_def.kind) {
            .struct_ => try self.generateStruct(type_def),
            .enum_ => try self.generateEnum(type_def),
            .union_ => try self.generateUnion(type_def),
        }
    }

    fn generateStruct(self: *Self, struct_def: *ir.TypeDef) !void {
        try self.writeLine("pub const {} = struct {{", .{struct_def.name});
        self.indent();

        // Generate fields with safety annotations
        for (struct_def.fields) |field| {
            try self.writeLine("{}: {},", .{field.name, self.typeToZig(field.type)});
        }

        // Generate safety verifications if needed
        if (self.codegen.safety_level == .strict) {
            try self.generateSafetyChecks(struct_def);
        }

        self.dedent();
        try self.writeLine("};\n");
    }

    fn generateSafetyChecks(self: *Self, type_def: *ir.TypeDef) !void {
        try self.writeLine("pub fn verify(self: *const @This()) !void {");
        self.indent();

        // Add ownership verification
        try self.writeLine("try safety.verifyOwnership(self);");

        // Add memory safety checks
        try self.writeLine("try safety.verifyMemorySafety(self);");

        self.dedent();
        try self.writeLine("}");
    }

    fn typeToZig(self: Self, ir_type: *ir.Type) []const u8 {
        return switch (ir_type.kind) {
            .i32 => "i32",
            .u32 => "u32",
            .f32 => "f32",
            .bool => "bool",
            .string => "[]const u8",
            .custom => ir_type.name,
        };
    }
};
